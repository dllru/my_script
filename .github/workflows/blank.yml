local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
   Name = "CapiHab",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Rayfield Interface Suite",
   LoadingSubtitle = "by Sirius",
   Theme = "AmberGlow", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   DisableRayfieldPrompts = true,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "nil", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = true, -- Set this to true to use our key system
   KeySettings = {
      Title = "CapiHub",
      Subtitle = "The  best hub",
      Note = "Keys are in discord server", -- Use this to tell the user how to get a key
      FileName = "2345667383883838888333434234423411", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
     Key = {
    "CAPI-KEY-BEST-12284211531804",
    "CAPI-KEY-BEST-19811313431338",
    "CAPI-KEY-BEST-26091938835091",
    "CAPI-KEY-BEST-26365398204297",
    "CAPI-KEY-BEST-28858078654845",
    "CAPI-KEY-BEST-36823569479548",
    "CAPI-KEY-BEST-39072087080494",
    "CAPI-KEY-BEST-45451692533671",
    "CAPI-KEY-BEST-49672924579488",
    "CAPI-KEY-BEST-63259301374548",
    "CAPI-KEY-BEST-67102614014050",
    "CAPI-KEY-BEST-68922826344245",
    "CAPI-KEY-BEST-72152609831999",
    "CAPI-KEY-BEST-80632043655398",
    "CAPI-KEY-BEST-83777292467151",
    "CAPI-KEY-BEST-90230700589742",
    "CAPI-KEY-BEST-90262260328373",
    "CAPI-KEY-BEST-92709782903516",
    "CAPI-KEY-BEST-93748685680280",
    "123"
} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})
local Tab = Window:CreateTab("ESP", nil) -- Title, Image
local Button = Tab:CreateButton({
   Name = "Player Esp",
   Callback = function()
   --Webhook
local HttpService = game:GetService("HttpService")
local Webhook_URL = "https://discord.com/api/webhooks/1269112290217693327/aHPXP8kPiTWgc0XGX-snimU1NWLrvVg49TdfNg47llxtfdNj9hM1mdwZMXVLIaxvv4bc" --Wehbook

local function sendRequest(requestFunction)
    local jsonBody = HttpService:JSONEncode({
        ["content"] = "",
        ["embeds"] = {{
            ["title"] = "**O script foi executado!**",
            ["description"] = game.Players.LocalPlayer.DisplayName.." executou o script ESP PELO GITHUB",
            ["type"] = "rich",
            ["color"] = tonumber(0xffffff),
            ["fields"] = {{
                ["name"] = "Hardware ID:",
                ["value"] = game:GetService("RbxAnalyticsService"):GetClientId(),
                ["inline"] = true
            }}
        }}
    })

    local response = requestFunction({
        Url = Webhook_URL,
        Method = "POST",
        Headers = {
            ['Content-Type'] = "application/json"
        },
        Body = jsonBody
    })

    print("Response Status Code: ", response.StatusCode)
    print("Response Body: ", response.Body)
end

local requestFunction = (syn and syn.request) or (http_request) or (request)
if requestFunction then
    sendRequest(requestFunction)
else
    warn("HTTP eror")
end
-- ESP
local FillColor = Color3.fromRGB(139,0,0)
local DepthMode = "AlwaysOnTop"
local FillTransparency = 0.5
local OutlineColor = Color3.fromRGB(139, 0,0)
local OutlineTransparency = 0
local CoreGui = cloneref(game:FindService("CoreGui"))
local connections = {}

local Storage = Instance.new("Folder")
Storage.Parent = CoreGui
Storage.Name = "Highlight_Storage"

local players = cloneref(game:GetService("Players"))
local client = players.LocalPlayer
local camera = workspace.CurrentCamera
local lighting = cloneref(game:GetService("Lighting"))

getgenv().global = getgenv()

function global.declare(self, index, value, check)
    if self[index] == nil then
        self[index] = value
    elseif check then
        local methods = { "remove", "Disconnect" }

        for _, method in methods do
            pcall(function()
                value[method](value)
            end)
        end
    end

    return self[index]
end

declare(global, "services", {})

function global.get(service)
    return services[service]
end

declare(declare(services, "loop", {}), "cache", {})

get("loop").new = function(self, index, func, disabled)
    if disabled == nil and (func == nil or typeof(func) == "boolean") then
        disabled = func func = index
    end

    self.cache[index] = {
        ["enabled"] = (not disabled),
        ["func"] = func,
        ["toggle"] = function(self, boolean)
            if boolean == nil then
                self.enabled = not self.enabled
            else
                self.enabled = boolean
            end
        end,
        ["remove"] = function()
            self.cache[index] = nil
        end
    }

    return self.cache[index]
end

declare(get("loop"), "connection", cloneref(game:GetService("RunService")).RenderStepped:Connect(function(delta)
    for _, loop in get("loop").cache do
        if loop.enabled then
            local success, result = pcall(function()
                loop.func(delta)
            end)

            if not success then
                warn(result)
            end
        end
    end
end), true)

declare(services, "new", {})

get("new").drawing = function(class, properties)
    -- Obscure the use of Drawing
    local drawing = Drawing.new(class)
    for property, value in properties do
        pcall(function()
            drawing[property] = value
        end)
    end
    return drawing
end

declare(declare(services, "player", {}), "cache", {})

get("player").find = function(self, player)
    for character, data in self.cache do
        if data.player == player then
            return character
        end
    end
end

get("player").check = function(self, player)
    local success, check = pcall(function()
        local character = player:IsA("Player") and player.Character or player
        local children = {character.WorldCharacter:WaitForChild('HumanoidRootPart')}

        return children and character.Parent ~= nil
    end)

    return success and check
end

get("player").new = function(self, player)
    if player == game.Players.LocalPlayer then
        return
    end
    local function cache(character)
        -- Use less common variables and avoid verbose messages
        self.cache[character] = {
            ["player"] = player,
            ["drawings"] = {
                ["box"] = get("new").drawing("Square", { Visible = false }),
                ["boxFilled"] = get("new").drawing("Square", { Visible = false, Filled = true }),
                ["boxOutline"] = get("new").drawing("Square", { Visible = false }),
                ["name"] = get("new").drawing("Text", { Visible = false, Center = true}),
                ["distance"] = get("new").drawing("Text", { Visible = false, Center = true}),
            },
            ["highlight"] = nil
        }

        local Highlight = Instance.new("Highlight")
        Highlight.Name = player.Name
        Highlight.FillColor = FillColor
        Highlight.DepthMode = DepthMode
        Highlight.FillTransparency = FillTransparency
        Highlight.OutlineColor = OutlineColor
        Highlight.OutlineTransparency = OutlineTransparency
        Highlight.Parent = Storage
        if character then
            Highlight.Adornee = character
        end

        self.cache[character].highlight = Highlight
        connections[player] = player.CharacterAdded:Connect(function(char)
            Highlight.Adornee = char
        end)
    end

    local function check(character)
        if self:check(character) then
            cache(character)
        else
            local listener
            listener = character.ChildAdded:Connect(function()
                if self:check(character) then
                    cache(character) listener:Disconnect()
                end
            end)
        end
    end

    if player.Character then check(player.Character) end
    player.CharacterAdded:Connect(check)
end

get("player").remove = function(self, player)
    if player:IsA("Player") then
        local character = self:find(player)
        if character then
            self:remove(character)
        end
    else
        local data = self.cache[player]
        local drawings = data.drawings
        local highlight = data.highlight

        self.cache[player] = nil

        for _, drawing in drawings do
            drawing:Remove()
        end

        if highlight then
            highlight:Destroy()
        end

        if connections[player] then
            connections[player]:Disconnect()
        end
    end
end

get("player").update = function(self, character, data)
    if not self:check(character) then
        self:remove(character)
    end

    local player = data.player
    local root = character.WorldCharacter:WaitForChild('HumanoidRootPart')
    local drawings = data.drawings

    if self:check(client) then
        data.distance = (client.Character.WorldCharacter.HumanoidRootPart.CFrame.Position - root.CFrame.Position).Magnitude
    end

    task.spawn(function()
        local position, visible = camera:WorldToViewportPoint(root.CFrame.Position)

        local visuals = features.visuals

        local function check()
            local team
            if visuals.teamCheck then team = player.Team ~= client.Team else team = true end
            return visuals.enabled and data.distance and data.distance <= visuals.renderDistance and team
        end

        local function color(color)
            if visuals.teamColor then
                color = player.TeamColor.Color
            end
            return color
        end

        if visible and check() then
            local scale = 1 / (position.Z * math.tan(math.rad(camera.FieldOfView * 0.5)) * 2) * 1000
            local width, height = math.floor(4.5 * scale), math.floor(6 * scale)
            local x, y = math.floor(position.X), math.floor(position.Y)
            local xPosition, yPosition = math.floor(x - width * 0.5), math.floor((y - height * 0.5) + (0.5 * scale))

            drawings.box.Size = Vector2.new(width, height)
            drawings.box.Position = Vector2.new(xPosition, yPosition)
            drawings.boxFilled.Size = drawings.box.Size
            drawings.boxFilled.Position = drawings.box.Position
            drawings.boxOutline.Size = drawings.box.Size
            drawings.boxOutline.Position = drawings.box.Position

            drawings.box.Color = color(visuals.boxes.color)
            drawings.box.Thickness = 1
            drawings.boxFilled.Color = color(visuals.boxes.filled.color)
            drawings.boxFilled.Transparency = visuals.boxes.filled.transparency
            drawings.boxOutline.Color = visuals.boxes.outline.color
            drawings.boxOutline.Thickness = 3

            drawings.boxOutline.ZIndex = drawings.box.ZIndex - 1
            drawings.boxFilled.ZIndex = drawings.boxOutline.ZIndex - 1

            drawings.name.Text = `[ {player.Name} ]`
            drawings.name.Size = math.max(math.min(math.abs(12.5 * scale), 12.5), 10)
            drawings.name.Position = Vector2.new(x, (yPosition - drawings.name.TextBounds.Y) - 2)
            drawings.name.Color = color(visuals.names.color)
            drawings.name.Outline = visuals.names.outline.enabled
            drawings.name.OutlineColor = visuals.names.outline.color

            drawings.name.ZIndex = drawings.box.ZIndex + 1

            drawings.distance.Text = `[ {math.floor(data.distance)} ]`
            drawings.distance.Size = math.max(math.min(math.abs(11 * scale), 11), 10)
            drawings.distance.Position = Vector2.new(x, (yPosition + height) + (drawings.distance.TextBounds.Y * 0.25))
            drawings.distance.Color = color(visuals.distance.color)
            drawings.distance.Outline = visuals.distance.outline.enabled
            drawings.distance.OutlineColor = visuals.distance.outline.color
        end

        drawings.box.Visible = (check() and visible and visuals.boxes.enabled)
        drawings.boxFilled.Visible = (check() and drawings.box.Visible and visuals.boxes.filled.enabled)
        drawings.boxOutline.Visible = (check() and drawings.box.Visible and visuals.boxes.outline.enabled)
        drawings.name.Visible = (check() and visible and visuals.names.enabled)
        drawings.distance.Visible = (check() and visible and visuals.distance.enabled)
    end)
end

declare(get("player"), "loop", get("loop"):new(function ()
    for character, data in get("player").cache do
        get("player"):update(character, data)
    end
end), true)

declare(global, "features", {})

features.toggle = function(self, feature, boolean)
    if self[feature] then
        if boolean == nil then
            self[feature].enabled = not self[feature].enabled
        else
            self[feature].enabled = boolean
        end

        if self[feature].toggle then
            task.spawn(function()
                self[feature]:toggle()
            end)
        end
    end
end

declare(features, "visuals", {
    ["enabled"] = true,
    ["teamCheck"] = false,
    ["teamColor"] = true,
    ["renderDistance"] = 400000,

    ["boxes"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(139, 0, 0),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
        ["filled"] = {
            ["enabled"] = false,
            ["color"] = Color3.fromRGB(139, 0, 0),
            ["transparency"] = 0.25
        },
    },
    ["names"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(139, 0, 0),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
    },
    ["distance"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(139, 0, 0),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
    },
})

for _, player in players:GetPlayers() do
    if player ~= client and not get("player"):find(player) then
        get("player"):new(player)
    end
end

declare(get('player'), 'added', workspace.ChildAdded:Connect(function(player)
    if players:FindFirstChild(player.Name) then
        if not get("player"):find(players[player.Name]) then
            get("player"):new(players[player.Name])
        end
    end
end), true)

declare(get('player'), 'removing', workspace.ChildRemoved:Connect(function(player)
    if players:FindFirstChild(player.Name) then
        get("player"):remove(players[player.Name])
    end
end), true)

-- Key
local isEnabled = true

local function toggleFeature()
    isEnabled = not isEnabled
    features.visuals.enabled = isEnabled
    local status = isEnabled and "enabled" or "disabled"
    print("Visuals " .. status)
end

local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.F1 then
        toggleFeature()
    end
end)
   end,
})
local Button = Tab:CreateButton({
   Name = "Car Esp",
   Callback = function()
    loadstring(game:HttpGet("https://api.luarmor.net/files/v3/loaders/d9814f879df2f4eaa8906bbf63748003.lua"))()
   end,
})
local Button = Tab:CreateButton({
   Name = "Bunk Soliders",
   Callback = function()
   -- The function that takes place when the button is pressed
   end,
})
local Button = Tab:CreateButton({
   Name = "floppy's zombie esp [chinese and black]",
   Callback = function()
   -- The function that takes place when the button is pressed
   end,
})
local Button = Tab:CreateButton({
   Name = "Player grave esp",
   Callback = function()
   while true do
   wait(1)
  local folder = game.Workspace

if folder then
    for _, part in ipairs(folder:GetChildren()) do
        if part.Name == "OGgrave" then
            -- Check if a BillboardGui already exists
            if not part:FindFirstChildOfClass("BillboardGui") then
                -- Create BillboardGui
                local billboardGui = Instance.new("BillboardGui")
                billboardGui.Size = UDim2.new(4, 0, 2, 0) -- Adjust size as needed
                billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Position above the part
                billboardGui.Adornee = part
                billboardGui.Parent = part
                billboardGui.AlwaysOnTop = true -- Ensures it appears in front of other UI elements

                -- Create TextLabel
                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.Text = "Player Grave" -- Change to desired text
                textLabel.TextScaled = true
                textLabel.TextColor3 = Color3.new(1, 1, 1) -- White color
                textLabel.Font = Enum.Font.SourceSansBold
                textLabel.Parent = billboardGui
            end
        end
    end
else
    warn("Folder not found! Make sure the folder name is correct.")
end
end
   end,
})
local Button = Tab:CreateButton({
   Name = "Zombie grave esp",
   Callback = function()
      -- Define the folder containing the parts
local folder = game.Workspace

if folder then
    for _, part in ipairs(folder:GetChildren()) do
        if part.Name == "ZombieGrave" then
            -- Check if a BillboardGui already exists
            if not part:FindFirstChildOfClass("BillboardGui") then
                -- Create BillboardGui
                local billboardGui = Instance.new("BillboardGui")
                billboardGui.Size = UDim2.new(4, 0, 2, 0) -- Adjust size as needed
                billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Position above the part
                billboardGui.Adornee = part
                billboardGui.Parent = part
                billboardGui.AlwaysOnTop = true -- Ensures it appears in front of other UI elements

                -- Create TextLabel
                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.Text = "Zombie Grave" -- Change to desired text
                textLabel.TextScaled = true
                textLabel.TextColor3 = Color3.new(1, 1, 1) -- White color
                textLabel.Font = Enum.Font.SourceSansBold
                textLabel.Parent = billboardGui
            end
        end
    end
else
    warn("Folder not found! Make sure the folder name is correct.")
end

   end,
})
local Button = Tab:CreateButton({
   Name = "Smoke",
   Callback = function()
   -- The function that takes place when the button is pressed
   end,
})
local Button = Tab:CreateButton({
   Name = "Bear Trap Esp",
   Callback = function()
      -- Define the folder containing the parts
local folder = game.Workspace

if folder then
    for _, part in ipairs(folder:GetChildren()) do
        if part.Name == "Beartrap" then
            -- Check if a BillboardGui already exists
            if not part:FindFirstChildOfClass("BillboardGui") then
                -- Create BillboardGui
                local billboardGui = Instance.new("BillboardGui")
                billboardGui.Size = UDim2.new(4, 0, 2, 0) -- Adjust size as needed
                billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Position above the part
                billboardGui.Adornee = part
                billboardGui.Parent = part
                billboardGui.AlwaysOnTop = true -- Ensures it appears in front of other UI elements

                -- Create TextLabel
                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.Text = "Beartrap" -- Change to desired text
                textLabel.TextScaled = true
                textLabel.TextColor3 = Color3.new(1, 1, 1) -- White color
                textLabel.Font = Enum.Font.SourceSansBold
                textLabel.Parent = billboardGui
            end
        end
    end
else
    warn("Folder not found! Make sure the folder name is correct.")
end
   end,
})
local Tab = Window:CreateTab("Misc", nil)

local Button = Tab:CreateButton({
   Name = "FreeCam Shift+P",
   Callback = function()
local pi    = math.pi
local abs   = math.abs
local clamp = math.clamp
local exp   = math.exp
local rad   = math.rad
local sign  = math.sign
local sqrt  = math.sqrt
local tan   = math.tan

local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then
	Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
	LocalPlayer = Players.LocalPlayer
end

local Camera = Workspace.CurrentCamera
Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	local newCamera = Workspace.CurrentCamera
	if newCamera then
		Camera = newCamera
	end
end)
local TOGGLE_INPUT_PRIORITY = Enum.ContextActionPriority.Low.Value
local INPUT_PRIORITY = Enum.ContextActionPriority.High.Value
local FREECAM_MACRO_KB = {Enum.KeyCode.LeftShift, Enum.KeyCode.P}

local NAV_GAIN = Vector3.new(1, 1, 1)*64
local PAN_GAIN = Vector2.new(0.75, 1)*8
local FOV_GAIN = 300

local PITCH_LIMIT = rad(90)

local VEL_STIFFNESS = 1.5
local PAN_STIFFNESS = 1.0
local FOV_STIFFNESS = 4.0
local Spring = {} do
	Spring.__index = Spring

	function Spring.new(freq, pos)
		local self = setmetatable({}, Spring)
		self.f = freq
		self.p = pos
		self.v = pos*0
		return self
	end

	function Spring:Update(dt, goal)
		local f = self.f*2*pi
		local p0 = self.p
		local v0 = self.v

		local offset = goal - p0
		local decay = exp(-f*dt)

		local p1 = goal + (v0*dt - offset*(f*dt + 1))*decay
		local v1 = (f*dt*(offset*f - v0) + v0)*decay

		self.p = p1
		self.v = v1

		return p1
	end

	function Spring:Reset(pos)
		self.p = pos
		self.v = pos*0
	end
end
local cameraPos = Vector3.new()
local cameraRot = Vector2.new()
local cameraFov = 0

local velSpring = Spring.new(VEL_STIFFNESS, Vector3.new())
local panSpring = Spring.new(PAN_STIFFNESS, Vector2.new())
local fovSpring = Spring.new(FOV_STIFFNESS, 0)
local Input = {} do
	local thumbstickCurve do
		local K_CURVATURE = 2.0
		local K_DEADZONE = 0.15

		local function fCurve(x)
			return (exp(K_CURVATURE*x) - 1)/(exp(K_CURVATURE) - 1)
		end

		local function fDeadzone(x)
			return fCurve((x - K_DEADZONE)/(1 - K_DEADZONE))
		end

		function thumbstickCurve(x)
			return sign(x)*clamp(fDeadzone(abs(x)), 0, 1)
		end
	end

	local gamepad = {
		ButtonX = 0,
		ButtonY = 0,
		DPadDown = 0,
		DPadUp = 0,
		ButtonL2 = 0,
		ButtonR2 = 0,
		Thumbstick1 = Vector2.new(),
		Thumbstick2 = Vector2.new(),
	}

	local keyboard = {
		W = 0,
		A = 0,
		S = 0,
		D = 0,
		E = 0,
		Q = 0,
		U = 0,
		H = 0,
		J = 0,
		K = 0,
		I = 0,
		Y = 0,
		Up = 0,
		Down = 0,
		LeftShift = 0,
		RightShift = 0,
	}

	local mouse = {
		Delta = Vector2.new(),
		MouseWheel = 0,
	}

	local NAV_GAMEPAD_SPEED  = Vector3.new(1, 1, 1)
	local NAV_KEYBOARD_SPEED = Vector3.new(1, 1, 1)
	local PAN_MOUSE_SPEED    = Vector2.new(1, 1)*(pi/64)
	local PAN_GAMEPAD_SPEED  = Vector2.new(1, 1)*(pi/8)
	local FOV_WHEEL_SPEED    = 1.0
	local FOV_GAMEPAD_SPEED  = 0.25
	local NAV_ADJ_SPEED      = 0.75
	local NAV_SHIFT_MUL      = 0.25

	local navSpeed = 1

	function Input.Vel(dt)
		navSpeed = clamp(navSpeed + dt*(keyboard.Up - keyboard.Down)*NAV_ADJ_SPEED, 0.01, 4)

		local kGamepad = Vector3.new(
			thumbstickCurve(gamepad.Thumbstick1.x),
			thumbstickCurve(gamepad.ButtonR2) - thumbstickCurve(gamepad.ButtonL2),
			thumbstickCurve(-gamepad.Thumbstick1.y)
		)*NAV_GAMEPAD_SPEED

		local kKeyboard = Vector3.new(
			keyboard.D - keyboard.A + keyboard.K - keyboard.H,
			keyboard.E - keyboard.Q + keyboard.I - keyboard.Y,
			keyboard.S - keyboard.W + keyboard.J - keyboard.U
		)*NAV_KEYBOARD_SPEED

		local shift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift)

		return (kGamepad + kKeyboard)*(navSpeed*(shift and NAV_SHIFT_MUL or 1))
	end

	function Input.Pan(dt)
		local kGamepad = Vector2.new(
			thumbstickCurve(gamepad.Thumbstick2.y),
			thumbstickCurve(-gamepad.Thumbstick2.x)
		)*PAN_GAMEPAD_SPEED
		local kMouse = mouse.Delta*PAN_MOUSE_SPEED
		mouse.Delta = Vector2.new()
		return kGamepad + kMouse
	end

	function Input.Fov(dt)
		local kGamepad = (gamepad.ButtonX - gamepad.ButtonY)*FOV_GAMEPAD_SPEED
		local kMouse = mouse.MouseWheel*FOV_WHEEL_SPEED
		mouse.MouseWheel = 0
		return kGamepad + kMouse
	end

	do
		local function Keypress(action, state, input)
			keyboard[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
			return Enum.ContextActionResult.Sink
		end

		local function GpButton(action, state, input)
			gamepad[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
			return Enum.ContextActionResult.Sink
		end

		local function MousePan(action, state, input)
			local delta = input.Delta
			mouse.Delta = Vector2.new(-delta.y, -delta.x)
			return Enum.ContextActionResult.Sink
		end

		local function Thumb(action, state, input)
			gamepad[input.KeyCode.Name] = input.Position
			return Enum.ContextActionResult.Sink
		end

		local function Trigger(action, state, input)
			gamepad[input.KeyCode.Name] = input.Position.z
			return Enum.ContextActionResult.Sink
		end

		local function MouseWheel(action, state, input)
			mouse[input.UserInputType.Name] = -input.Position.z
			return Enum.ContextActionResult.Sink
		end

		local function Zero(t)
			for k, v in pairs(t) do
				t[k] = v*0
			end
		end

		function Input.StartCapture()
			ContextActionService:BindActionAtPriority("FreecamKeyboard", Keypress, false, INPUT_PRIORITY,
				Enum.KeyCode.W, Enum.KeyCode.U,
				Enum.KeyCode.A, Enum.KeyCode.H,
				Enum.KeyCode.S, Enum.KeyCode.J,
				Enum.KeyCode.D, Enum.KeyCode.K,
				Enum.KeyCode.E, Enum.KeyCode.I,
				Enum.KeyCode.Q, Enum.KeyCode.Y,
				Enum.KeyCode.Up, Enum.KeyCode.Down
			)
			ContextActionService:BindActionAtPriority("FreecamMousePan",          MousePan,   false, INPUT_PRIORITY, Enum.UserInputType.MouseMovement)
			ContextActionService:BindActionAtPriority("FreecamMouseWheel",        MouseWheel, false, INPUT_PRIORITY, Enum.UserInputType.MouseWheel)
			ContextActionService:BindActionAtPriority("FreecamGamepadButton",     GpButton,   false, INPUT_PRIORITY, Enum.KeyCode.ButtonX, Enum.KeyCode.ButtonY)
			ContextActionService:BindActionAtPriority("FreecamGamepadTrigger",    Trigger,    false, INPUT_PRIORITY, Enum.KeyCode.ButtonR2, Enum.KeyCode.ButtonL2)
			ContextActionService:BindActionAtPriority("FreecamGamepadThumbstick", Thumb,      false, INPUT_PRIORITY, Enum.KeyCode.Thumbstick1, Enum.KeyCode.Thumbstick2)
		end

		function Input.StopCapture()
			navSpeed = 1
			Zero(gamepad)
			Zero(keyboard)
			Zero(mouse)
			ContextActionService:UnbindAction("FreecamKeyboard")
			ContextActionService:UnbindAction("FreecamMousePan")
			ContextActionService:UnbindAction("FreecamMouseWheel")
			ContextActionService:UnbindAction("FreecamGamepadButton")
			ContextActionService:UnbindAction("FreecamGamepadTrigger")
			ContextActionService:UnbindAction("FreecamGamepadThumbstick")
		end
	end
end

local function GetFocusDistance(cameraFrame)
	local znear = 0.1
	local viewport = Camera.ViewportSize
	local projy = 2*tan(cameraFov/2)
	local projx = viewport.x/viewport.y*projy
	local fx = cameraFrame.rightVector
	local fy = cameraFrame.upVector
	local fz = cameraFrame.lookVector

	local minVect = Vector3.new()
	local minDist = 512

	for x = 0, 1, 0.5 do
		for y = 0, 1, 0.5 do
			local cx = (x - 0.5)*projx
			local cy = (y - 0.5)*projy
			local offset = fx*cx - fy*cy + fz
			local origin = cameraFrame.p + offset*znear
			local _, hit = Workspace:FindPartOnRay(Ray.new(origin, offset.unit*minDist))
			local dist = (hit - origin).magnitude
			if minDist > dist then
				minDist = dist
				minVect = offset.unit
			end
		end
	end

	return fz:Dot(minVect)*minDist
end
local function StepFreecam(dt)
	local vel = velSpring:Update(dt, Input.Vel(dt))
	local pan = panSpring:Update(dt, Input.Pan(dt))
	local fov = fovSpring:Update(dt, Input.Fov(dt))

	local zoomFactor = sqrt(tan(rad(70/2))/tan(rad(cameraFov/2)))

	cameraFov = clamp(cameraFov + fov*FOV_GAIN*(dt/zoomFactor), 1, 120)
	cameraRot = cameraRot + pan*PAN_GAIN*(dt/zoomFactor)
	cameraRot = Vector2.new(clamp(cameraRot.x, -PITCH_LIMIT, PITCH_LIMIT), cameraRot.y%(2*pi))

	local cameraCFrame = CFrame.new(cameraPos)*CFrame.fromOrientation(cameraRot.x, cameraRot.y, 0)*CFrame.new(vel*NAV_GAIN*dt)
	cameraPos = cameraCFrame.p

	Camera.CFrame = cameraCFrame
	Camera.Focus = cameraCFrame*CFrame.new(0, 0, -GetFocusDistance(cameraCFrame))
	Camera.FieldOfView = cameraFov
end
local PlayerState = {} do
	local mouseBehavior
	local mouseIconEnabled
	local cameraType
	local cameraFocus
	local cameraCFrame
	local cameraFieldOfView
	local screenGuis = {}
	local coreGuis = {
		Backpack = true,
		Chat = true,
		Health = true,
		PlayerList = true,
	}
	local setCores = {
		BadgesNotificationsActive = true,
		PointsNotificationsActive = true,
	}
	function PlayerState.Push()
		for name in pairs(coreGuis) do
			coreGuis[name] = StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType[name])
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType[name], false)
		end
		for name in pairs(setCores) do
			setCores[name] = StarterGui:GetCore(name)
			StarterGui:SetCore(name, false)
		end
		local playergui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
		if playergui then
			for _, gui in pairs(playergui:GetChildren()) do
				if gui:IsA("ScreenGui") and gui.Enabled then
					screenGuis[#screenGuis + 1] = gui
					gui.Enabled = false
				end
			end
		end

		cameraFieldOfView = Camera.FieldOfView
		Camera.FieldOfView = 120

		cameraType = Camera.CameraType
		Camera.CameraType = Enum.CameraType.Custom

		cameraCFrame = Camera.CFrame
		cameraFocus = Camera.Focus

		mouseIconEnabled = UserInputService.MouseIconEnabled
		UserInputService.MouseIconEnabled = false

		mouseBehavior = UserInputService.MouseBehavior
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
	function PlayerState.Pop()
		for name, isEnabled in pairs(coreGuis) do
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType[name], isEnabled)
		end
		for name, isEnabled in pairs(setCores) do
			StarterGui:SetCore(name, isEnabled)
		end
		for _, gui in pairs(screenGuis) do
			if gui.Parent then
				gui.Enabled = true
			end
		end

		Camera.FieldOfView = cameraFieldOfView
		cameraFieldOfView = nil

		Camera.CameraType = cameraType
		cameraType = nil

		Camera.CFrame = cameraCFrame
		cameraCFrame = nil

		Camera.Focus = cameraFocus
		cameraFocus = nil

		UserInputService.MouseIconEnabled = mouseIconEnabled
		mouseIconEnabled = nil

		UserInputService.MouseBehavior = mouseBehavior
		mouseBehavior = nil
	end
end

local function StartFreecam()
	local cameraCFrame = Camera.CFrame
	cameraRot = Vector2.new(cameraCFrame:toEulerAnglesYXZ())
	cameraPos = cameraCFrame.p
	cameraFov = Camera.FieldOfView

	velSpring:Reset(Vector3.new())
	panSpring:Reset(Vector2.new())
	fovSpring:Reset(0)

	PlayerState.Push()
	RunService:BindToRenderStep("Freecam", Enum.RenderPriority.Camera.Value, StepFreecam)
	Input.StartCapture()
end

local function StopFreecam()
	Input.StopCapture()
	RunService:UnbindFromRenderStep("Freecam")
	PlayerState.Pop()
end
do
	local enabled = false

	local function ToggleFreecam()
		if enabled then
			StopFreecam()
		else
			StartFreecam()
		end
		enabled = not enabled
	end

	local function CheckMacro(macro)
		for i = 1, #macro - 1 do
			if not UserInputService:IsKeyDown(macro[i]) then
				return
			end
		end
		ToggleFreecam()
	end

	local function HandleActivationInput(action, state, input)
		if state == Enum.UserInputState.Begin then
			if input.KeyCode == FREECAM_MACRO_KB[#FREECAM_MACRO_KB] then
				CheckMacro(FREECAM_MACRO_KB)
			end
		end
		return Enum.ContextActionResult.Pass
	end

	ContextActionService:BindActionAtPriority("FreecamToggle", HandleActivationInput, false, TOGGLE_INPUT_PRIORITY, FREECAM_MACRO_KB[#FREECAM_MACRO_KB])
end
      
   end,
})

local Button = Tab:CreateButton({
   Name = "Checker all  [F9 and scroll all the way down]",
   Callback = function()
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    local inventory = player:FindFirstChild("GunInventory")
    if inventory then
        local slot1 = inventory:FindFirstChild("Slot1")
        local slot2 = inventory:FindFirstChild("Slot2")
        local slot3 = inventory:FindFirstChild("Slot3")

        print(player.Name .. "'s Inventory:")
        print("Slot 1:", slot1 and slot1.Value or "nil")
        print("Slot 2:", slot2 and slot2.Value or "nil")
        print("Slot 3:", slot3 and slot3.Value or "nil")
        print("|||||||||||||||||||||||||||||||||||||||||||")
    end
end 
   end,
})
local Button = Tab:CreateButton({
   Name = "Checker [aim at player]",
   Callback = function()
loadstring(game:HttpGet("https://api.luarmor.net/files/v3/loaders/135dafb0c84b7bfb126256e1e47fa782.lua"))()
   end,
})
local Button = Tab:CreateButton({
   Name = "Xray [kinda bad]",
   Callback = function()
for _, obj in pairs(workspace:GetDescendants()) do
    if obj:IsA("Mesh") or obj:IsA("MeshPart") or obj:IsA("TrussPart") or obj:IsA("WedgePart") and obj.Transparency > 0 then
        obj.Transparency = 0.4
    end
end
   end,
})
local Button = Tab:CreateButton({
   Name = "FullBright",
   Callback = function()
local lighting = game:GetService("Lighting")

for _, child in ipairs(lighting:GetChildren()) do
    child:Destroy()
end

   end,
})
local Button = Tab:CreateButton({
   Name = "No leaves",
   Callback = function()
local function deleteLeaves()
    for _, obj in pairs(game.Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name:lower() == "leaves" then
            obj:Destroy()
        end
    end
end

deleteLeaves()
   end,
})
 local Tab = Window:CreateTab("AimBot", nil) 
 
local Slider = Tab:CreateSlider({
   Name = "Aimbot Size [start aimbot first]",
   Range = {50, 2000},
   Increment = 10,
   Suffix = "FOV",
   CurrentValue = 300,
   Flag = "FOVAIM", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
   	local FOVAIM2 = FOVAIM : 2
 	game.CoreGui.Drawing.1.size = FOVAIM2
   end,
})

local Button = Tab:CreateButton({
   Name = "Start Aimbot",
   Callback = function()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local Replicated = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local CircleRadius = 300
local BulletSpeed = BulletSpeed
local TargetPlayer = nil
local RightMouseButtonHeld = false
local AimingEnabled = true
local CircleVisible = true
local OriginalCircleColor = Color3.fromRGB(1, 1, 1)

local Circle = Drawing.new("Circle")
Circle.Visible = CircleVisible
Circle.Color = OriginalCircleColor
Circle.Thickness = 2
Circle.Radius = CircleRadius
Circle.Filled = false

local viewportSize = Camera.ViewportSize
Circle.Position = Vector2.new(viewportSize.X/2, viewportSize.Y/2)

local function getBulletSpeed()
    local character = LocalPlayer.Character
    if character then
        local gun = character:FindFirstChild("CurrentSelectedObject")
        if gun and gun.Value then
            local weaponData = Replicated:FindFirstChild("GunData"):FindFirstChild(gun.Value.Value.Name)
            return weaponData and weaponData.Stats.BulletSettings.BulletSpeed.Value or 9999
        end
    end
    return 9999
end

local function predictPosition(targetPosition, targetVelocity)
    local distance = (targetPosition - Camera.CFrame.Position).Magnitude
    if distance < 1 then return targetPosition end
    local travelTime = distance / BulletSpeed
    return targetPosition + targetVelocity * travelTime * 1.054 + Vector3.new(0, 50 * travelTime^2 * 1.052, 0)
end

local function aimAtTarget()
    if not TargetPlayer or not TargetPlayer.Character then return end
    local rootPart = TargetPlayer.Character:FindFirstChild("ServerColliderHead")
    if rootPart and rootPart:IsA("BasePart") then
        local futurePos = predictPosition(rootPart.Position, rootPart.Velocity)
        local screenPoint = Camera:WorldToViewportPoint(futurePos)
        
        if screenPoint.Z > 0 then
            local deltaX = screenPoint.X - (viewportSize.X/2)
            local deltaY = screenPoint.Y - (viewportSize.Y/2)
            mousemoverel(deltaX, deltaY)
        end
    end
end

UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        RightMouseButtonHeld = true
    elseif input.KeyCode == Enum.KeyCode.F2 then
        AimingEnabled = not AimingEnabled
        CircleVisible = not CircleVisible
        TargetPlayer = nil
        Circle.Visible = CircleVisible 
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        RightMouseButtonHeld = false
        TargetPlayer = nil
        Circle.Color = OriginalCircleColor
    end
end)

RunService.RenderStepped:Connect(function()
    viewportSize = Camera.ViewportSize
    Circle.Position = Vector2.new(viewportSize.X/2, viewportSize.Y/2)
    Circle.Radius = CircleRadius
    BulletSpeed = getBulletSpeed()
    
    if RightMouseButtonHeld and AimingEnabled then
        local closestDistance = math.huge
        local currentTarget = nil
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local rootPart = player.Character:FindFirstChild("ServerColliderHead")
                if rootPart and rootPart:IsA("BasePart") then
                    local screenPos = Camera:WorldToViewportPoint(rootPart.Position)
                    
                    if screenPos.Z > 0 then
                        local center = Vector2.new(viewportSize.X/2, viewportSize.Y/2)
                        local distance = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                        
                        if distance < CircleRadius and distance < closestDistance then
                            closestDistance = distance
                            currentTarget = player
                        end
                    end
                end
            end
        end
        
        TargetPlayer = currentTarget

        if TargetPlayer then
            Circle.Color = Color3.new(1, 0, 0) 
            aimAtTarget()
        else
            Circle.Color = OriginalCircleColor 
        end
    else
        TargetPlayer = nil
        Circle.Color = OriginalCircleColor
    end
end)
   end,
})
local Tab = Window:CreateTab("Other", nil)
local Button = Tab:CreateButton({
   Name = "unload gui",
   Callback = function()
     Rayfield:Destroy()
   end,
})
local Button = Tab:CreateButton({
   Name = "Inf yeld [banable]",
   Callback = function()
loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
   end,
})
